---  
id: cache  
title: 缓存  
---  

# 缓存  

缓存 API 的作用是跟踪已创建的体积，管理内存使用，并在尝试分配超出应用程序定义的限制的数据时提醒主机应用程序。  

该模块处理图像和体积的缓存。  

缓存有两个主要组件：用于图像的易失部分和用于体积的非易失部分。我们将为整个缓存分配一个共享的内存块，例如 1GB，这将用于图像和体积的共享。  

- 单独的 2D 图像是易失的，并将被新的图像替代。  
- 当你分配体积时，它会将该体积使用的图像标记为非易失的，除非你释放该体积。  

## 缓存工具  

有多种工具函数可以帮助你管理缓存。  

- **isCacheable**：`Cache` API 提供的众多工具函数之一是 `isCacheable`，你可以使用它来检查在发起体积或图像的获取请求之前是否有足够的可用空间。  
- **purgeCache**：删除缓存中的所有图像和体积。  
- **decacheIfNecessaryUntilBytesAvailable**：根据请求的字节数，必要时清除缓存。  

## 缓存优化  

缓存中的所有数据实际上是 `image` 对象。当你请求一个体积时，我们会按需将体积所需的图像传递给 GPU，在任何时候我们都不会将体积的体素数据存储在缓存中。如果你需要访问体积的体素数据，你可以使用 `VoxelManager` 类来进行操作。  

如果你确实需要体积的完整体素数据，可以使用 `VoxelManager` 类方法 `.getCompleteScalarDataArray()` 来获取完整的体素数据。  

在 `Cornerstone3D` 2.x 版本中引入的这一新变化是新的基于图像的方法的一部分，旨在提高性能、减少内存使用并提供更高效的数据访问，尤其适用于大型数据集。  

以下是新方法的其他优势：  
1. 单一数据源  

   - 之前：数据存在于图像缓存和体积缓存中，导致同步问题。  
   - 现在：只有一个数据源——图像缓存。  
   - 好处：改善了堆栈和体积分割之间的同步。  

2. 新的体积创建方法  

   - 现在所有内容都作为图像加载。  
   - 体积流式传输按图像逐个进行。  
   - 只有图像被缓存到图像缓存中。  
   - 对于体积渲染，数据直接从图像缓存传递到 GPU，绕过 CPU 的体素数据。  
   - 好处：消除了 CPU 中对体素数据的需求，减少了内存使用，提升了性能。  

3. 工具的 VoxelManager  

   - 充当索引和体素数据之间的中介。  
   - 提供从 IJK 到索引的映射。  
   - 在不创建体素数据的情况下检索信息。  
   - 单独处理每个图像。  
   - 好处：有效处理需要 CPU 中像素数据的工具。  

4. 处理非图像体积  

   - 没有图像的体积（例如 NIFTI）会被切割并转换为堆栈格式。  
   - 使非图像体积与新的基于图像的方法兼容。  

5. 优化的缓存机制  

   - 数据以原生格式存储，而不是总是缓存为 float32。  
   - 在更新 GPU 纹理时，按需转换为所需的格式。  
   - 好处：减少内存使用，消除不必要的数据类型转换。  

6. 消除 SharedArrayBuffer  

   - 移除了对 SharedArrayBuffer 的依赖。  
   - 每个解码的图像直接按正确的大小和位置传输到 GPU 3D 纹理中。  
   - 好处：减少了安全限制，简化了 Web Worker 实现。  